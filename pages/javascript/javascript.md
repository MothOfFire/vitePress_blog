---
layout: doc
title: "JavaScript"
---

## JavaScript 基础

### JavaScript 简介

- JavaScript 是一个运行在浏览器端的脚本语言

- 但是实质今日 JS 的运行环境已经不仅仅局限于浏览器（Node.js）

- JS 是一个动态类型的语言

- JS 的标准被称为 ECMAScript （ECMA262）

- 自 2015 年起，ES 标准每年(6 月)更新
  ES2015(ES6)
  ES2016
  ...
  ES2020

- 这一阶段主要学习的内容：

  - ES 标准

  ​ 基本语法

  - DOM

    文档对象模型，用来操作网页

  - BOM

    浏览器对象模型，用来操作浏览器

### JS 的编写位置

**1 可以直接将 js 代码编写在 script 标签中**

```html
<script>
  alert("Hello!");
</script>
```

- script 标签要放在 head 标签或 body 标签中，不要写在 html 标签内；

**2 可以将 js 代码编写在外部的 js 文件中，然后通过 script 标签进行引入**

```html
<script src="xxx.js"></script>
```

- 一个 script 标签要么用来引入，要么用来写代码，不能同时进行；

```html
<!--错误示范-->
<script src="xxx.js">
  alert('Hello!');
</script>
<!--正确示范-->
<script src="xxx.js"></script>
<script>
  alert("Hello!");
</script>
```

**3 还可以将 js 代码编写在标签的指定属性中**

```html
<button onclick="alert('你点我做什么？');">点击按钮</button>
<button onmuseenter="alert('你点我做什么？');">点击按钮</button>
```

**4 可以将 js 代码编写在 href 属性的后边，以 javascript:开头**

```html
<!--超链接执行js代码-->
<a href="javascript:alert('Hello');">我是一个超链接</a>
```

### 打印语句

**alert()**

- 用来在窗口弹出一个警告框；

**console**

- console.log();
  - 用来在控制台输出一个日志；

**document**

document 是当前网页的意思。

- document.write(' ');
  - 用来向网页输出一个内容

### 注释

通过注释对代码进行解释说明，也可以禁止一些代码的执行。

一定要养成一个良好的编写注释的习惯，注释要求要简单明了。

**1 单行注释**

```js
// 注释
```

**2 多行注释**

```js
/**多
 * 行
 * 注释
 */
```

### 基本语法

- **JS 每一条语句都应该以分号结尾**
- 在 js 中有自动添加分号的机制，所有即使不写分号也不会报错；
- **JS 中严格区分大小写**

- **JS 中多个换行和空格会被忽略**
- 所以可以通过多个空格和换行对代码进行格式化（让代码格式更好看）

### 字面量和变量

#### 1 字面量

- 字面量就是一个一个的值，像 1、2、'hello'、true...
  - 所有的字面量在 JS 中都可以直接使用，但是一般不会这么做，一般都是通过变量来存储字面量。

#### 2 变量

- 变量用来存储值，一个变量可以用来“存储”任意值
- 并且变量中“存储”的值可以任意修改
- JS 中的变量并没有直接存储值，而是存储值的内存地址
- JS 中的变量更像是一个值的别名

##### 2.1 变量的使用

- 声明变量：

  let 变量名;
  var 变量名;（老版本）

- 为变量赋值
  变量名 = 值;

- 声明和赋值同时进行
  let 变量名 = 值;
  var 变量名 = 值;

- 声明常量

  const 常量名 = 值;

  - 常量只能进行一次赋值无法修改

##### 2.2 变量、函数的提升

- 在 JS 中，使用 var 声明的变量，会在所有的代码执行前被声明，但是不会赋值，所以我们可以在变量声明前就对其进行访问，这个特点称为变量的提升，变量提升只提升声明。
- 使用 function 开头的函数会在所有代码执行前被创建，所以我们可以在函数声明前对其进行调用，这个特点称为函数的提升。

```javascript
console.log(a);
var a = 10;
//在控制台输出underfined
console.log(b);
b = 10;
//在控制台中报错，没有找到变量
fn(); //可以执行
fn2(); //不可以执行，var声明的变量默认为underfined
function fn() {
  console.log("函数1");
}
var fn2 = function () {
  console.log("函数2");
};
fn(); //可以执行
fn2(); //可以执行
```

### 标识符

- js 中所有可以自主命名的内容都可以认为是标识符
  像：变量名、函数名、类名、(属性名)

- 规范： 1.标识符中可以含有字母、数字、\_、$，但是不能以数字开头 2.标识符不能是 js 中的关键字和保留字，也不建议使用 js 中的内置函数名、变量名作为标识符 3.标识符采用驼峰命名法
  小驼峰

  ​ 首字母小写，每个单词开头大写，其余小写
  ​ xyyyzzz --> xxxYyyZzz
  ​ 大驼峰（类名）

  ​ 首字母大写写，每个单词开头大写，其余小写
  ​ xyyyzzz --> XxxYyyZzz

### 数据类型

#### 1 基本数据类型（不可变类型）

**基本数据类型是构成整个 js 世界的基石**

基本数据类型都是不可变类型，值一旦创建就不可修改

- string（字符串）

  - JS 中的字符串使用引号引起来，单双都行，但是不要混合

  - 同类型的引号不要发生嵌套

  - 转义字符串，js 中使用 \ 作为转义字符

```js
    \' -->  '
    \" -->  "
    \t -->  制表符
    \n -->  换行
    \\ -->  \
```

- 模板字符串（新增的）老版本的浏览器不支持

  - 使用 `（反单引号）来表示模板字符串模板字符串可以跨行使用，并且在模板中可以直接嵌入变量

  - 例子：

```javascript
let str = `xxxx ${变量}`;
```

- 使用 typeof 检查一个字符串时，它会返回 'string'

- 特点：

  1. 可以换行，并保留字符串中的格式
  2. 在模板字符串中可以直接嵌入变量

- number（数值）

  - 在 js 中所有的整数和浮点数（小数）都是 number 类型

  - 特殊的数字：

    Infinity （正无穷）
    NaN （非法数字）---Not a Number

  - 其他进制的数字
    二进制：0b 开头
    八进制：0o 开头
    十六进制：0x 开头

  - 在 js 中可以确保大部分的整数运算取得一个精确的结果（别太大，16 位以内)，小数运算可能会得到一个近似值，所以不要直接在 js 中进行精度要求高的运算（尤其是涉及到钱的--一般在后台来算）

  - 当数值超过一定范围后，会使用 Infinity 来表示

  - 使用 typeof 检查数字时，会返回 'number'

  - 大整数(bigint)

    - ES2020 中新推出的数值类型，大整数需要以 n 结尾。

```javascript
let num1 = 1000n;
console.log(typeof num1);
```

    - 使用 typeof 检查大整数时，会返回 'bigint'

- boolean（布尔值）

  - 布尔值用来进行逻辑判断，布尔值只有两个：
    true 表示真
    false 表示假
  - 使用 typeof 检查 boolean 时会返回 'boolean'

- null（空值）

  - 空值用来表示一个空的对象，只有一个值
    null
  - 使用 typeof 检查空值时，返回'object'

- undefined（未定义）

- 未定义用来表示声明但没有赋值的变量，只有一个值
  undefined
- 使用 typeof 检查未定义时，会返回 'undefined'
- 一般我们不会主动使用 undefined

#### 2 类型转换

- 类型转换指将其他的类型转换为 number、string、boolean

- 转化为 string

  - 显式类型转换

    1. 调用 toString()方法

```javascript
let a = 10;
a = a.toString();
```

_不适用于 null 和 undefined（它们调用会报错），因为 null 和 undefined 不含有 toString()方法_

    2. 调用 String()函数

```javascript
let a = 10;
a = String(a);
```

对于有 toString()值，也是调用 toString()
对于没有 toString()的 null 和 undefined，直接转换为 'null'和'undefined'

- 隐式类型转换

  1. 为任意值加上一个空串（''），即可将其转换为字符串

```javascript
let a = 10;
a = a + "";
```

原理同 String()函数

- 转化为 number

  - 显式类型转换

    1. 使用 Number()函数

```javascript
let a = "10";
a = Number(a);
```

**不同的情况：**
字符串
如果一个字符串是合法的数字，则直接转换为对应的数字
如果不合法则转换为 NaN
如果是空串或空格串，则转换为 0
布尔值：
true --> 1
false --> 0
null-->0
undefined --> NaN

    2. 专门用来转换字符串的两个函数：

       parseInt()

       - 将一个字符串解析为一个整数

    - 该函数会自左向右依次读取字符串中的字符，直到找到字符串中的所有的合法整数为止（例如'123px'--->123）

      - 还可以用来给一个数值取整

      parseFloat()

      - 将一个字符串解析为小数
      - 该函数会自左向右依次读取字符串中的字符，直到找到字符串中的所有的合法浮点数为止（例如'3.14px4565'--->3.14）

- 隐式类型转换

  **我们可以通过为任意值（字符串除外）-0，\*1 等方式来将其转化为数字；**

  1. 使用一元的+来将一个任意值转换为数字

     - 例子：

```javascript
let a = 1 + "2" + 3;
console.log("a =", a, typeof a);
//a = '123' String
let a = 1 + +"2" + 3;
console.log("a =", a, typeof a);
//a = 6 number
```

       - 原理： 同 Number()函数

- 转化为 boolean

  - 显示类型转换

    1. 使用 Boolean()函数来进行转换

```javascript
let a = 123;
a = Boolean(a);
```

会转换为 false 的情况：0、NaN、null、undefined、false、''

- 隐式类型转换

  1. 为任意值取两次反，来将其转换为布尔值

```javascript
let a = 123;
a = !!a;
```

#### 3 可变类型

##### 对象（Object）

- 对象是 JS 中的一种复合数据类型，在对象中可以存储其他的数据

- 基本数据类型都是一个一个独立的值，值与值之间不存在任何关系，这样就导致我们无法在程序中表示一些复杂的数据

- 对象相当于是一个容器(复合数据类型)，在对象中可以存储不同类型的数据

- 对象中存储的数据被称为属性，向对象中添加数据称为添加属性。

- 比较两个对象时，无论是相等还是全等都是比较对象的内存地址

- 创建对象的方法

  let obj = Object();

  let obj = new Object();

  let obj = {};

  通过构造函数来创建对象;

- 向对象添加属性---->

  对象.属性名 = 属性值;

  对象['属性名'] = 属性值;

- 读取对象中的属性---->

  对象.属性名;-->简洁

  对象['属性名'];-->灵活

- 删除对象中的属性---->

  delete 对象.属性名;

  delete 对象['属性名'];

- 创建对象时直接指定对象中的属性---->

  {

  属性名:属性值,

  属性名:属性值,

  属性名:属性值,

  属性名:属性值

  }

- 使用 typeof 检查对象时会返回'Object'

```javascript
//创建一个空的对象
let obj = new Object(); //let obj = Object();
obj.name = "孙悟空";
obj.age = 18;
obj.gender = "男";
console.log(obj);
console.log(obj.name);
delete obj.gender;
console.log(obj.gender);
```

**属性名**

- 当我们访问一个对象中没有的属性时，不会报错而是返回 underfined
- 对象的属性是任意值，不需要遵守标识符的规范，但是如果起的名字太特殊，必须采取另外的方式进行命名------->对象['属性名'] = 属性值
- 虽然不需要遵守标识符的规范，但属性名尽量遵循标识符的规范。

```javascript
let obj = Object();
obj["name"] = "孙悟空";
obj["age"] = 18;
obj["gender"] = "男";
let a = "name";
console.log(obj[a]);
n;
for (let n in obj) {
  console.log(n, "=", obj[n]);
}
```

**属性值**

- 对象的属性值可以是任意数据类型

```javascript
let obj = Object();
obj["name"] = "孙悟空";
obj["age"] = 18;
obj["gender"] = "男";
obj.test = Object();
obj.test.name = "老张";
console.log(obj);
console.log(obj.test.name);
console.log("name" in obj);
```

**对象字面量**

- 以字面量的形式来创建对象

- 可以直接使用{}来创建一个对象

- 字面量可以在创建对象时直接向对象中添加属性

- 语法--->

  {

  属性名:属性值,

  属性名:属性值,

  属性名:属性值,

  属性名:属性值

  }

```javascript
let obj = {
    name:'孙悟空'，
    age:18
};
let obj2 = Object();
console.log(obj,typeof obj);
console.log(obj2,typeof obj2);
```

**对象的分类**

- 内建对象
  - 由 ES 标准所规定的对象
  - Object、Function、String、Boolean、Number、Array、Math、Date、JSON...
- 宿主对象
  - 由 JS 运行环境所提供的对象
  - Window、Console、Document....
- 自定义对象
  - 由开发人员自己定义的对象

##### 工厂方法创建对象

```javascript
function createPerson(name, age, gender, address) {
  //创建一个对象
  let obj = {};
  //let obj = {
  //    name,
  //    age,
  //    gender,
  //    address,
  //    sayHello(){
  //        alert(`大家好，我是${this.name}`);
  //    }
  //};
  //向对象中添加属性
  obj.name = name;
  obj.age = age;
  obj.gender = gender;
  obj.address = address;
  obj.sayHello = function () {
    alert(`大家好，我是${this.name}`);
  };
  //将对象作为返回值返回
  return obj;
}
let per = createPerson("孙悟空", 18, "男", "花果山");
let per2 = createPerson("白骨精", 16, "女", "白骨山");
console.log(per);
console.log(per2);
```

##### 改变量与改对象

- 当一个不可变类型的变量的值被修改时，只会影响它自己，对其他变量不会产生任何影响。

- 当我们对对象进行修改时（改对象），如果有其他的变量指向该对象，则也会被影响到

- 变量与变量之间是相互独立的，改变量对其他变量不会有影响

  变量 = xxx

  变量 += xxx

  变量++

- 改对象会影响到其他指向改对象的变量

  对象.属性名 = xxx;

  对象['属性名'] = xxx;

- 声明常量是禁止修改变量，不会影响我们修改对象

```javascript
const obj = Object();
obj.name = "swk";
console.log(obj);
obj.name = "zbj";
console.log(obj);
```

### 运算符

1. typeof 运算符

- 用来检查一个值的类型；

```javascript
let num1 = 10;
console.log(typeof num1); //在控制台打印num1的类型
```

- 运算符也称为操作符，可以对一个或多个值进行各种运算或操作

2. 算术运算符

```bash
    + 加法运算符
    - 减法运算符
    * 乘法运算符
    / 除法运算符
    ** 幂运算符 （新增的）
    %  模运算符
```

注意:除了字符串的加法（字符串的拼接），其余类型的值进行算术运算时，都会转换为数值然后再运算
任何值和 NaN 做任何运算结果都是 NaN（除了字符串加法）
字符串的加法:任何值和字符串做加法时都会转换为字符串，然后再和字符串进行拼串。 3. 一元运算符

```javascript
//+ 正号，不会对数值产生任何影响
//- 负号，会对数值进行符号位取反
let a = 10;
a = +a;
console.log(a);
a = -a;
console.log(a);
```

注意：_使用 ± 号，会发生类型转换（数值）_
对于非数值类型的值进行正负运算时，它会先将其转换为数值然后再进行正负运算。

```javascript
let a = true;
console.log(a, typeof a);
a = -a;
console.log("a =", a, typeof a);
```

可以利用一元的+，将一个任意的值转换为数值，原理同 Number()函数，但是更加简单。

```javascript
let a = 1 + "2" + 3;
console.log("a =", a, typeof a); //a = '123' String
let a = 1 + +"2" + 3;
console.log("a =", a, typeof a); //a = 6 number
```

4. 自增自减运算符

```javascript
//自增
//1.(后++)
//a++
//a++会使变量立即自增1，并返回变量自增前的值（原值）
//2.(前++)
//++a
//++a会使变量立即自增1，并返回变量自增后的值（新值）
let a = 10;
console.log("a =", ++a); //控制台打印 a = 11
console.log("a =", a++); //控制台打印 a = 11
console.log("a =", a); //控制台打印   a = 12
//自减：
//1.(后--)
//a--
//a--会使变量立即自减1，并返回变量自减前的值（原值）
//2.(前--)
//--a 会使变量立即自减 1，并返回变量自减后的值（新值）
```

5. 赋值运算符

```js
    =
    //将符号右侧的值赋值给左侧变量
    +=
    //a += x 等价于 a = a + x
    -=
    *=
    /=
    **=
    %=

```

那些情况会导致变量发生变化（为变量进行重新赋值）

- 对变量使用赋值运算符

a = x;
a += x;
a -= x;
.....

- 对变量使用自增自减

a++;

++a;

a--;

--a;

6. 逻辑运算符

   !（逻辑非）

   - 逻辑非用来对一个值进行取反，true 变 false，false 变 true

   - 非布尔值会转换为布尔值然后再取反

   - 对于任意值取两次反来将其转换为布尔值；

```javascript
let a = 10;
console.log("a =", a, typeof a); //a = 10 "number"
a = !!a;
console.log("a =", a, typeof a); //a = true "boolean"
```

​ &&（逻辑与）

- 两边的值都为 true 时，返回 true，否则返回 false
- 与运算是找 false 的，只要有 false 就会返回 false
- 与运算是短路的与，如果第一个值是 false，则不看第二个值
- 非布尔值运算时，会首先将其转换为布尔值，然后运算，最终返回原值
- 如果第一个值是 false，则直接返回第一个值，
- 如果第一个值为 true，则返回第二个值

||（逻辑或）

- 两边的值有一个为 true 时，返回 true，否则返回 false
- 或运算是找 true 的，有 true 就返回 true，没有返回 false
- 或运算是短路的或，如果第一个值是 true，则不看第二个值
- 非布尔值运算时，会返回原值;如果第一个值是 true，则返回第一个值;如果第一个值是 false，则返回第二个值

7. 关系运算符

- 关系运算赋用来比较两个值之间大小等于的关系,如果关系成立，返回 true，否则返回 false
- 如果比较两个字符串的大小关系，它不会将字符串转换为数值去比较而是逐位的比较字符的 Unicode 编码，所以利用这个特性可以通过比较字符串大小来将字符串按照字母顺序排序。
- 任何值和 NaN 作比较最终的返回值都是 false
- 规则同数学运算

```javascript
//>
//>=
//<
//<=
let a = 10;
5 < a < 20; //错的
a > 5 && a < 20; //正确
```

- 相等和全等

  - 相等运算符

  ==（相等）

  - 检查两个值是否相等，相等返回 true，否则返回 false 它会做自动的类型转换，如果两个值的类型不同它会将其转换为相同的类型然后再比较（通常是转换为数字进行比较）

  !=（不等）

  - 检查两个值是否不相等，不相等返回 true，否则返回 false
  - 会做自动的类型转换

  - 全等

    ===（全等）

    - 检查两个值是否全等，不会做自动的类型转换

    !==（不全等）

    - 检查两个值是否不全等，不会做自动的类型转换

- 条件运算符（三元运算符、三目运算符）:

  - 语法：

    条件表达式 ? 语句 1 : 语句 2

  - 执行流程：
    条件运算符在执行时，先对条件表达式进行求值判断，如果为 true，则执行语句 1.如果为 false，则执行语句 2.

- in 运算符
  - 检查一个对象是否含有某个属性，使用 in 运算符，有返回 true，没有返回 false
  - 如果属性存在于对象的原型中也会返回 true
- 语法-----> '属性名' in 对象
- for-in 运算符

  - for-in 用来对对象中的属性进行枚举，就是将对象中的上属性全部取出来

  - 语法---->

    for(let 变量 in 对象){

    语句.....

    }

  - for-in 会执行多次，对象中有几个属性就会执行几次,每次执行都会将一个属性名赋值给我们定义的变量

- instanceof 运算符

  - 用来检查一个对象是否是一个类的实例

  - 就是检查对象的原型链上是否有类的存在，Object 是所有对象的祖先

  - 语法---->

    对象 instanceof 类（构造函数）

### 代码块

- 在 JS 中使用{}来表示代码块即为代码进行分组，代码块用来为代码分组同一个代码块中的代码要么都执行要么都不执行
- 使用 var 声明的变量，没有块作用域
- 使用 let 声明的变量，具有块作用域，
  let 声明的变量，只能在块内部访问，无法在块外访问

### 流程控制语句

代码默认是按照自上向下的顺序一行一行执行的，但仅仅这样并不能满足我们的开发需求，我们可以通过流程控制语句来改变程序执行的顺序：

条件判断语句

条件分支语句

循环语句

#### 条件判断语句：

**1.if 语句**

- if 语句
  if(条件表达式){
  语句...
  }

**2.if-else 语句**

- if(条件表达式){
  语句...
  }else{
  语句...
  }

**3.if - else if - else 语句**

- if(条件表达式){
  语句...
  }else if(条件表达式){
  语句...
  }else if(条件表达式){
  语句...
  }else{
  语句...
  }

- 执行流程：
  if 语句在执行时，自上向下对条件表达式进行求值判断，
  如果结果为 true，则执行 if 后的语句，执行完毕语句结束
  如果结果为 false，则继续向下判断，直到找到 true 为止
  如果所有的都是 false，则执行 else 后的语句

#### 条件分支语句：

**switch 语句**

- 语法：
  switch(条件表达式){
  case 表达式:
  语句..
  break;
  case 表达式:
  语句...
  break;
  default:
  语句...
  break;
  }
- 执行流程：
  switch 语句在执行时，会自上向下将 switch 后的条件表达式
  和 case 后的表达式做全等比较，
  结果为 true，自当前 case 处开始执行代码
  结果 false，则继续向下判断，直到找到 true 为止
  所有都是 false，则自 default 处开始执行代码

#### 循环语句：

- 循环语句可以使指定的代码反复执行多次

**while 循环**

- 语法：
  while(条件表达式){
  语句...
  }
- 执行流程：
  while 循环在执行时，会先对条件表达式进行求值判断，
  如果结果为 false，则循环结束
  如果结果为 true，则执行循环体，
  执行完毕继续对条件表达式进行求值判断，以此类推。

**do-while 循环**

- 语法：
  do{
  语句...
  }while(条件表达式)
- 执行流程：
  do-while 循环在执行时，会先执行 do 后的循环体，
  执行完毕对 while 后的条件表达式进行求值判断
  如果为 false，则循环结束
  如果为 true，则继续执行循环体 以此类推

- do-while 是先执行后判断，while 是先判断后执行
  do-while 可以确保循环可以至少执行一次

**for 循环**

- 语法：
  for(① 初始化表达式;② 条件表达式;④ 更新表达式){
  ③ 语句...
  }
- 执行流程：
  for 循环在执行时：
  ① 执行初始化表达式，初始化一个变量
  ② 对条件表达式进行求值判断
  如果为 false，则语句结束
  ③ 如果为 true，则执行循环体
  ④ 循环体执行完毕，执行更新表达式，对变量进行更新
  ⑤ 重复 ②

**break 和 continue**

- break 用来立刻结束离它最近的 switch 语句或循环语句
- continue 用来跳过当次的循环语句

**性能优化的关键是减少循环的次数**

**计时器：**

计时器可以用来测试程序的执行时间：

- console.time() 开始计时器
- console.timeEnd() 结束计时器

### 垃圾回收（垃圾收集 GC）

- 就像生活中会产生垃圾，程序运行一段时间后也会产生垃圾，生活中的垃圾会影响生活品质，程序中的垃圾会影响程序运行的速度
- 如果一个对象没有任何的变量对其进行引用，那么这个对象就是垃圾对象，垃圾对象大量存在会占用大量内存空间导致程序运行速度变慢，必须及时将这些垃圾进行清理，但是这些垃圾对象我们不需要处理，因为在 JS 中拥有自动的垃圾收集机制，它会将垃圾对象从内存中清楚，我们要做的就是将不再使用的变量设置为 null

### JS 的函数

#### 函数（function）

- 函数也是一个对象和其他对象功能一样

- 不同的是在函数中可以直接存储 JS 代码，并且可以在我们需要的时候进行反复的调用，即可以使代码复用

- 使用 typeof 检查对象时会返回'function'

- JS 禁止一个以 function 开头的函数没有名字

- 创建函数

  函数声明---->

  function 函数名([形参 1,形参 2,....形参 n]){

  函数体，js 语句

  }

  函数表达式---->

  let fn2 = function([形参 1,形参 2,....形参 n]){

  语句....

  };

  立即执行函数(IIFE)---->

  (function (){

  语句....

  })();

  (function (){

  语句....

  }());

  立即执行函数，会在函数创建后立刻调用，并且只会调用一次。

  _[]内的内容代表可以选择填入；_

- 函数调用

  - 函数调用就是将函数中存储的代码执行
  - 语法---->函数对象([实参 1,实参 2,....实参 n]);

```javascript
//创建一个函数
function fn() {
  alert("你好！");
  alert("Hello！");
}
let fn2 = function () {
  console.log("我是fn2");
};
//调用函数
fn();
fn2();
```

**参数**

- 形参（形式参数）:
  - 在定义函数时，可以在函数的（）中指定数量不等的形参。
  - 定义形参就相当于在函数中声明了变量，但是没有赋值。
- 实参（实际参数）
  - 在调用函数时，可以在函数的（）中传递数量不等的实参。
  - 实参将会赋值给对应的形参。
  - JS 中不会检查实参的类型与数量，可以传递任意类型的实参，也可以传递任意数量的实参，如果实参与形参数量相同，则对应的实参赋值给对应形参，如果实参少于形参的数量 ，则没有实参的形参默认为 underfined，如果实参多于形参的数量，则多余的实参不会使用。

```javascript
function sum(a, b) {
  if (typeof a == "number" && typeof b == "number") {
    console.log(a + b);
    return a + b;
  } else {
    console.log("类型错误");
    return "类型错误";
  }
}
let sum = sum(1, 2);
console.log(sum);
```

- 函数的返回值
  - 返回值就是函数的执行结果
  - 通过 return 来设置函数的返回值
  - 语法---->return 值;
  - 调用函数时可以定义一个变量来接受结果；
  - 任何值都可以作为函数的返回值
    - 如果不设置 return 或 return 不跟任何值，则相当于 return underfined
    - return 后的所有代码都不会执行，return 执行后函数立即结束

```javascript
//匿名函数
//错误示范
function (){
    console.log('我时一个匿名函数~');
}
//正确示范，立即执行函数(IIFE)
(function (){
    console.log('我时一个匿名函数~');
})
//调用,只能调用一次
(function (){
    console.log('我时一个匿名函数~');
})();
```

#### 方法（method）

- 任何值都可以成为对象的属性，函数也不例外
- 如果一个对象的属性是函数，则我们称这个函数是这个对象的方法（method）,调用函数就称为调用 xx 对象的 xx 方法。
- 函数和方法目前来讲只是称呼不同，没有本质的区别

```javascript
//这中写法兼容性更好
let obj = {
  test: function () {
    console.log("666");
  },
  tt: function () {
    console.log("999,6翻了");
  },
};
obj.test();
obj.tt();
//这种写法比较方便
let obj1 = {
  test() {
    console.log("666");
  },
  tt() {
    console.log("999,6翻了");
  },
};
obj1.test();
obj1.tt();
```

#### 构造函数（constructor）

- 构造函数就是专门用来创建对象的函数。
- 构造函数的定义和普通函数没有区别，唯一的不同点在于构造函数的名字首字母要大写。
- 构造函数和普通函数的区别在于调用方式

  - 一个函数如果直接调用，那么它就是一个普通函数
  - 如果使用 new 关键字调用，那么它就是一个构造函数

- 一个构造函数也称为一个类（class），通过构造函数创建出来的对象称为该类实例,通过同一类创建的对象，称为同一类对象。
- 构造函数执行流程
  - 1.执行构造函数时，会先创建一个新的对象
  - 2.将 this 设置为新的对象
  - 3.执行函数中的代码
  - 4.将新建的对象作为返回值返回

#### 常用内置函数

**alert()**

- 用来在窗口弹出一个警告框

**prompt()**

- 该函数用来获取用户输入的内容，用户输入的内容会作为返回值返回，需要定义变量来接收 ；返回值类型总是一个字符串

**hasOwnProperty()**

- 用来检查一个属性是否存在于对象自身中。
- 语法---->对象实例名.hasOwnProperty(属性名);

### 作用域（scope）

- 作用域就是指变量的作用范围

#### 全局作用域（global)

- 全局作用域在页面加载时创建，在页面关闭时销毁
- 所有的直接写在 script 标签的内容，都位于全局作用域中
- 全局作用域中定义的变量是全局变量，定义的函数是全局函数 ，全局变量和全局函数可以在任意位置被访问（在开发时很少在全局作用域中编写代码）
- 全局作用域中存在一个全局对象(global object)window，window 对象代表浏览器窗口。
- 在全局作用域中，所有使用 var 声明的变量都会作为 window 对象的属性保存，所有使用 function 声明的函数都会作为 window 对象的方法保存，函数实际上就是 window 对象的方法！
- let 声明的变量不会存储在 window 对象中
- 直接为一个没有声明的变量赋值，实际就相当于直接向 window 对象中添加属性

```javascript
c = 30;
//等价于
window.c = 30;
```

#### 局部作用域

**块作用域**

**函数作用域**

- 函数作用域在函数调用时创建，调用结束时销毁
- 函数每次调用都会产生一个新的函数作用域，每个函数作用域之间是相互独立的。
- 在函数作用域中声明的变量是局部变量，局部变量只能在函数内部使用，函数外部无法访问。_注意：在函数中声明变量时如果不使用 var 或 let，则变量会变成全局变量。（一定要注意）_
- 在函数作用域中可以访问全局作用域的变量，但是在全局作用域中无法访问函数作用域的变量。
- 变量和函数的提升在函数作用域中同样适用

#### 作用域链

- 当我们访问一个变量时，JS 会先在当前的作用域中寻找，如果有则直接使用，如果没有则去当前作用域的上一层作用域中寻找，找到了就直接使用，没找到就继续去上一层寻找，以此类推直到找到全局作用域，如果还没找到则报错--->xxx is not defined。
- JS 中的作用域叫做词法作用域，函数作用域由它定义的位置来决定的，和调用它的位置无关。

### this

- 在调用函数时，浏览器每次都会向函数中传递一个隐含的参数，这个参数的名字叫做 this，this 指向的是一个对象。
- 当我们以函数的形式调用一个函数时，this 是 window
- 当我们以方法的形式调用一个函数时，this 是调用方法的对象
- 当我们以构造函数的形式调用时，this 是新建对象

### 原型（prototype）

- 每个函数对象中都有一个属性叫做 prototype，该属性指向一个对象，这个对象就是原型对象。

- 如果函数作为普通函数调用，则原型对象（prototype）没有任何作用

- 如果函数作为构造函数调用，那么通过该构造函数所创建的对象中都会有一个隐含的属性 (`__proto__`)指向函数原型对象（prototype），也就是说该类的所有实例中都有一个隐含的属性指向构造函数的 prototype 原型对象，就相当于一个公共的区域可以被所有的该类实例访问，可以将一些实例共有的属性或方法存储在原型对象中，这样我们只需要设置一次即可让所有的对象都访问到该属性或方法

- 添加属性---->

  类名.prototype.属性名 = 属性值;

  添加方法---->

  类名.prototype.方法名 = function (){

  方法体；语句.....

  };

- 当我们访问一个对象的属性时，JS 会先在对象本身中寻找，如果找到则直接使用，如果没有找到则去对象的原型(`__proto__`)中去寻找，找到则使用,如果没找到则去原型的原型中寻找，如果找到则使用，如果没找到则以此类推直到找到 Object 的原型，如果依然没找到则返回 underfined，不会报错，这个搜索过程称为原型链

- 定义一个类时，如果属性和方法时对象独有的，就直接在构造函数中设置

  function 类名(){

  this.属性名 = 属性值;

  }

  如果属性和方法是公共的，每一个对象的值都是相同的，则可以通过原型来添加。

  类名.prototype.属性名 = 属性值;

  类名.prototype.方法名 = function (){

  方法体；语句.....

  };

- 显式原型---->`类名.prototype`
- 隐式原型---->`实例名.__proto__`，一般不会去修改，只查看
- 实例的隐式原型指向类（构造函数）的显式原型
- 如果原型中的方法不能满足我们的需求，可以选择创建一个同名的方法将其覆盖，这称为方法的重写

### 数组（Array）

- 数组也是一个对象，是内建对象

- 数组用来存储一组有序的数据

- 数组中存储的数据称为元素（element），数组的元素会根据存储的顺序保存在数组中

- 数组中的每一个元素都有唯一的索引（index），索引就是一组以 0 开始的整数，第一个元素的索引为 0，第二个为 1，以此类推.....

- 创建数组对象---->

  let 数组名 = new Array();

  let 数组名 = [];

- 向数组中添加元素---->

  数组名[索引] = 值;

- 读取数组中的元素---->

  数组名[索引];

  获取数组中没有的元素，不会报错而是返回 underfined

- 使用 typeof 检查对象时会返回'Object'
- 数组中可以存储任意数据类型，如果数组中存放的元素还是数组，则这个数组被称为二维数组
- 虽然数组里可以存储任意数据类型的元素，并且长度没有限制，但是我们在使用数组时要尽量确保数组中的数据类型是相同的

**属性**

length

- 用来获取数组中的元素的数量，它的值实际上是数组的最大索引+1
- 向数组的最后位置添加元素---->数组名[数组名.length] = 值；
- length 属性可以被修改
  - 如果将 length 改小，则后边的元素会被删除
  - 如果将 length 改大，则后边会多余空的元素

**方法**

push()

- 用来向数组的最后添加一个或多个元素
- 语法---->数组名.push(元素值, 元素值);
- 返回值是新的长度

pop()

- 从数组的最后删除一个元素
- 语法---->数组名.pop();
- 返回值是被删除的元素

unshift()

- 向数组的前边添加一个或多个元素
- 语法---->数组名.unshift(元素值, 元素值);
- 返回值是新的长度

shift()

- 删除数组的第一个元素
- 语法---->数组名.shift();
- 返回值是被删除的元素

slice()

- 用来截取数组
- 该方法不会影响到原来的数组，而是将结果作为返回值返回，称为非破坏性方法
- 参数---->
  - 1.截取的起始位置索引（包含起始位置）
  - 2.截取的结束位置索引（不包含结束位置）
  - 可以省略第二个参数，如果不写第二个参数则会截取到最后一个元素
  - 索引可以传负值，-1 表示倒数第一个，-2 表示倒数第二个以此类推

splice()

- 可以用来删除（开始位置索引,删除数量）、替换（开始位置索引,替换数量,元素值，元素值...）、添加（插入位置索引,0,元素值）数组中的元素
- 该方法会对原数组产生影响，是破坏性方法
- 返回值是被删除的元素
- 参数---->
  - 1.删除元素的起始位置索引（包含起始位置）
  - 2.删除的数量
  - 3.可以传递多个参数，这些参数将会作为新的元素添加到数组中

**数组的字面量**

- 使用[]来创建一个数组，和 new Array()效果一样
- 可以在创建数组时，同时向数组中添加元素

**数组的遍历**

- 遍历就是指获取到数组中的所有元素

```javascript
let arr = ["华", "苏"];
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
for (let i = arr.length - 1; i >= 0; i--) {
  console.log(arr[i]);
}
for (let i in arr) {
  console.log(arr[i]);
}
for (let v of arr) {
  console.log(v);
}
```

## JavaScript 高级
